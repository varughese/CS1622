# Part I: Lexical Analysis

In this part of the project you will implement a scanner for the [C- language](/view/cs1622sp2020/c-language?authuser=0). The scanner will read in a source file and produces a listing of each token one by one, annotated with the token kind (identifier, integer number, etc) and the location in the source. If invalid input is discovered, it will stop producing the error token annotated with the lexeme incorrectly recognized.

Before you start your scanner implementation, I recommend reading attentively [Chapter 3](https://www.google.com/url?q=https%3A%2F%2Fwww3.nd.edu%2F~dthain%2Fcompilerbook%2Fchapter3.pdf&sa=D&sntz=1&usg=AFQjCNGIpaKNmFBB6u9JtSwjL-TqdG8CcQ) from the book "Introduction to Compilers and Language Design" by Douglas Thain. While our language syntax is a little bit different from the one used in the book, the code examples and material can be extremely helpful.

You're using Flex, you can also refer to the following material:

*   [**Flex in a Nutshell**](https://www.google.com/url?q=https%3A%2F%2Fwww.dropbox.com%2Fs%2Fcfu2fvllatyvtg3%2F050%2520Flex%2520In%2520A%2520Nutshell.pdf&sa=D&sntz=1&usg=AFQjCNHdXOyaCdvl1CSVfN4aOYZzl0p3xg)

In your lexer implementation, consider the following classes of tokens in the language:

```
ID      Identifier
NUM     Literal decimal (integer)
KEY     Keyword
SYM     Lexical Symbol
ERROR   Lexeme of the first error found
```
</div>

Comments and white space should be discarded during the lexical analysis phase of the compiler. You should also print the line number where the token was found, including the error token. The lexical analyzer must stop after finding the first lexical error. **In the case of an unfinished comment error, the lexeme "/*" must be used for the ERROR token.** The output format is:

```
(line_num,token_type,"lexeme")
```
     
</div>

*   **Example of input file (main.c):**

```c
void main(void) {
	int a;
	a = 4 + 5;
}
```

## How to run it (two arguments: input and output)

The program should read the input from a file (source) and write the output to another file (target):

```
$ ./lexer main.c main.lex
```

</div>

*   **Example of output file generated by the lexer (main.lex)**

```
(1,KEY,"void")
(1,ID,"main")
(1,SYM,"(")
(1,KEY,"void")
(1,SYM,")")
(2,SYM,"{")
(3,KEY,"int")
(3,ID,"a")
(3,SYM,";")
(4,ID,"a")
(4,SYM,"=")
(4,NUM,"4")
(4,SYM,"+")
(4,NUM,"5")
(4,SYM,";")
(5,SYM,"}")
```

Make sure you also create two files in your submission folder: `**compile.sh**` and `**run.sh**` to compile and run your code, such as:

*   `compile.sh` (if you are using the Flex tool)

```sh
flex lexer.lex
gcc -o lexer lex.yy.c -ll
```

*   `run.sh` (takes two arguments as filenames)

```
./lexer $1 $2
```

### Reference compiler (lexical analysis)

*   Compiler binary (Linux ELF 64-bit LSB executable, x86-64) for the lexical phase can be found [here](https://www.google.com/url?q=https%3A%2F%2Fpitt-my.sharepoint.com%2F%3Au%3A%2Fg%2Fpersonal%2Fvtp4_pitt_edu%2FEYqSiG_rxJFMpJB4wTKlNDUBQ_Ux8anNWN--KIjf2hMjxg%3Fe%3DheWYaj&sa=D&sntz=1&usg=AFQjCNElgitnULm8qPKZA4DVIOFd2jblAw)
    *   If you're using Windows, you can install and use the Linux Ubuntu terminal! See [this tutorial](https://www.google.com/url?q=https%3A%2F%2Ftutorials.ubuntu.com%2Ftutorial%2Ftutorial-ubuntu-on-windows&sa=D&sntz=1&usg=AFQjCNHGZGmj-RPsE_2PokGCnxIWJa-4Sg)
*   Test cases [here](https://www.google.com/url?q=https%3A%2F%2Fpitt-my.sharepoint.com%2F%3Au%3A%2Fg%2Fpersonal%2Fvtp4_pitt_edu%2FEYMS71uaXRxDp2_-wupCu6oBXeZeJV-iqTvQhpqWq2koBQ%3Fe%3DCakHCH&sa=D&sntz=1&usg=AFQjCNFYHlLGF7K-I0v_N2GyxI6dkV8dwQ)
*   **IMPORTANT NOTE on Line Endings:** Text files created on DOS/Windows machines have different line endings than files created on Unix/Linux. DOS uses carriage return and line feed ("\r\n") as a line ending, which Unix uses just line feed ("\n"). You need to be careful about transferring files between Windows machines and Unix machines to make sure the line endings are translated properly.

</div>

</div>

</div>

</div>

</div>

</div>

</div>