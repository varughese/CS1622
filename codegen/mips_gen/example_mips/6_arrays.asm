# // Input
# int garr[15];
# void f(int a0, int a1) {
# 	int b; 
# 	int x[4]; 
#	int c;
#	x[3] = 622;
#	output(x[3]);
# }
# void main(void) {
#	f(1,2);
# }


# Part of this was generated by the compiler lol, which is
# why it looks kinda messy

.text
_f_output:
sub $sp, $sp, 4
sw $ra, 0($sp)
lw $a0, 4($sp)
li $v0, 1
syscall
li $v0, 11
li $a0, 0x0a
syscall
lw $ra, ($sp)
add $sp, $sp, 4
add $sp, $sp, 4
j $ra

_f_input:
li  $v0, 5
syscall
j $ra

.data
garr: .word 0:15 

.text
_f_f:
# Local variable [b], stack_pos [0] 
# Local variable [x], stack_pos [1] 
# Local variable [c], stack_pos [5] 
# parameter [a0], position [6]
# parameter [a1], position [7]
	 # f() [2] params, [6] local vars
sub $sp, $sp, 4 # push ra
sw  $ra, 0($sp)
sub $sp, $sp, 24 # push local vars
# {

lw  $t2, 28($sp) # a0
lw  $t1, 32($sp) # a1

li $t4, 610592
# http://people.cs.pitt.edu/~xujie/cs447/AccessingArray.htm
la  $t0, 4($sp) # Put the address of x into $t0
# x[3], we want to do, &x + (3 * 4) to get the address
# notice that 3 * 4 is also 3 << 2 (3 * 2 * 2).
# SO we could get shifty (use sll instruction)

# But, we could also just do 12($t0), which means the same thing
# I am pretty sure
# Option 1:
# li  $t3, 3
# sll $t3, $t3, 2 # t0 = 3 * 4
# add $t3, $t0, $t3
# sw $t4, ($t3)

# Option 2:
sw  $t4, 12($t0)

# x[3] = 610592


lw $t5, 12($t0)
# output(x[3])
sub $sp, $sp, 4 # push arg and call output
sw  $t5, ($sp)
jal _f_output

### Try same thing with global var
li $t5, 59595959
la $t0, garr
# 14 * 4 = 56
sw $t5, 56($t0)

li $t2 800 # just want to clear the register for testing

lw $t2, 56($t0)
sub $sp, $sp, 4 # push arg and call output
sw  $t2, ($sp)
jal _f_output


# }
add $sp, $sp, 24 # pop local vars
lw  $ra, ($sp)
add $sp, $sp, 4
add $sp, $sp, 8 # pop arguments 
j $ra

_f_main:
	 # main() [0] params, [0] local vars
sub $sp, $sp, 4 # push ra
sw  $ra, 0($sp)
sub $sp, $sp, 0 # push local vars
# {
li  $t1, 3
sub $sp, $sp, 4
sw  $t1, ($sp)
li  $t3, 2
sub $sp, $sp, 4
sw  $t3, ($sp)
jal _f_f
move $t4 $v0
# }
add $sp, $sp, 0 # pop local vars
lw  $ra, ($sp)
add $sp, $sp, 4
add $sp, $sp, 0 # pop arguments 
j $ra

main:
jal _f_main
li $v0, 10 # We need to do this syscall to exit
syscall # Or else it will error!


############## TAKEAWAYS (Any errors in running this is because of these notes down here)
# IF you have an array variable, just do 
la $t0 array_name # the symbol_codegen() function knows the address
# to assign like arr[p] = $t1
sw $t1, p*4($t0)
# to load
lw $t1, p*4($t0)

# So, EXPR_ASSIGN and EXPR_SUBSCRIPT will take care of these differences