%{

#define YYERROR_VERBOSE

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>

#include "ast/factory.h"
#include "ast/tostring.h"

extern int yylex();
extern int yyparse();
extern FILE* yyin;

void *parser_result;

void yyerror(const char* s);

/* Clunky: Manually declare the interface to the scanner generated by flex. */
extern char *yytext;
%}


%union {
    struct decl *decl;
	struct stmt *stmt;
	struct expr *expr;
	struct type *type;
	struct param_list *param_list;
	expr_t expr_t;
	int intval;
	char *name;
};

%token T_IF T_ELSE T_WHILE
%token T_INT
%token T_VOID
%token T_RETURN
%token<name> T_ID
%token<intval> T_NUM
%token T_EQUAL
%token T_ISEQ
%token T_NEQ
%token T_LT
%token T_LE
%token T_GT
%token T_GE
%token T_LPAREN
%token T_RPAREN
%token T_LBRACKET
%token T_RBRACKET
%token T_LBRACE
%token T_RBRACE
%token T_DOT
%token T_COMMA
%token T_PLUS
%token T_MINUS
%token T_MUL
%token T_DIV
%token T_SEMICOLON

%token ERROR_UNCLOSED_COMMENT
%token ERROR_INVALID_CHARACTER

%left T_PLUS T_MUL
%right T_RPAREN T_ELSE

%type <decl> program declaration_list var_declaration fun_declaration
%type <stmt> statement statement_list expression_stmt compound_stmt selection_stmt iteration_stmt return_stmt
%type <expr> expression additive_expression simple_expression term factor var call arg_list args
%type <type> type_specifier
%type <param_list> params param param_list
%type <expr_t> addop mulop relop

%start program
%%

program : declaration_list { parser_result = $$; }

declaration_list : declaration_list declaration { $$ = create_decl(0, 0, 0, 0, 0);  }
				 | declaration { $$ = create_decl(0, 0, 0, 0, 0);  }

declaration : var_declaration
			| fun_declaration

var_declaration : type_specifier T_ID T_SEMICOLON { $$ = create_decl(0, 0, 0, 0, 0);  }
				| type_specifier T_ID T_LBRACKET T_NUM T_RBRACKET T_SEMICOLON { $$ = create_decl(0, 0, 0, 0, 0); }

type_specifier : T_INT { $$ = create_type(TYPE_INTEGER, 0, 0); }
			   | T_VOID { $$ = create_type(TYPE_VOID, 0, 0); }

fun_declaration : type_specifier T_ID T_LPAREN params T_RPAREN compound_stmt { 
	// TODO Fill this with actual parts of the stack
	struct type *function_type = create_type(TYPE_FUNCTION, 0, 0);
	$$ = create_decl(0, function_type, 0, 0, 0);  
}

params : param_list { 
			// TODO make this a list somehow 
			$$ = create_param_list(0, 0, 0); 
		}
	   | T_VOID { $$ = create_param_list(0, 0, 0); }

param_list : param_list T_COMMA param  { $$ = create_param_list(0, 0, 0); }
		   | param { $$ = create_param_list(0, create_type(TYPE_VOID, 0, 0), 0); }

param : type_specifier T_ID { $$ = create_param_list(0, $1, 0); }
	  | type_specifier T_ID T_LBRACKET T_RBRACKET { $$ = create_param_list(0, $1, 0); }

compound_stmt : T_LBRACE local_declarations statement_list T_RBRACE { $$ = create_stmt(0, 0, 0, 0, 0, 0, 0, 0); }

local_declarations : local_declarations var_declaration 
				   | %empty

statement_list : statement statement_list { $$ = $1; $1->next = $2; }
			   | %empty { $$ = NULL; }

statement : expression_stmt 
		  | compound_stmt
		  | selection_stmt 
	      | iteration_stmt
		  | return_stmt

expression_stmt : expression T_SEMICOLON { 
					$$ = create_stmt(STMT_EXPR, 0, 0, $1, 0, 0, 0, 0); 
					print_expr($1); 
				}
				| T_SEMICOLON { 
					$$ = create_stmt(STMT_EXPR, 0, create_expr(EXPR_SEMICOLON, 0, 0), 0, 0, 0, 0, 0); 
				}

selection_stmt : T_IF T_LPAREN expression T_RPAREN statement { 
					$$ = create_stmt(STMT_IF_ELSE, 0, $3, 0, 0, $5, 0, 0); 
				}
			   | T_IF T_LPAREN expression T_RPAREN statement T_ELSE statement { 
				   $$ = create_stmt(STMT_IF_ELSE, 0, $3, 0, 0, $5, $7, 0); 
				}

iteration_stmt : T_WHILE T_LPAREN expression T_RPAREN statement { 
					$$ = create_stmt(STMT_ITERATION, 0, 0, 0, 0, 0, 0, 0); 
				}

return_stmt : T_RETURN T_SEMICOLON { $$ = create_stmt(0, 0, 0, 0, 0, 0, 0, 0); } 
			| T_RETURN expression T_SEMICOLON { $$ = create_stmt(0, 0, 0, 0, 0, 0, 0, 0); }

expression : var T_EQUAL expression { $$ = create_expr(EXPR_ASSIGN, $1, $3); }
		   | simple_expression { $$ = $1; }

var : T_ID { $$ = expr_create_name($1); }
	| T_ID T_LBRACKET expression T_RBRACKET { $$ = create_expr(EXPR_SUBSCRIPT, expr_create_name($1), $3); }

simple_expression : additive_expression relop additive_expression { $$ = create_expr($2, $1, $3); } 
                  | additive_expression { $$ = $1; }

relop : T_LE { $$ = EXPR_LE; }
	  | T_LT { $$ = EXPR_LT; }
	  | T_GT { $$ = EXPR_GT; }
	  | T_GE { $$ = EXPR_GE; }
	  | T_ISEQ { $$ = EXPR_ISEQ; }
	  | T_NEQ { $$ = EXPR_NEQ; }

additive_expression : additive_expression addop term { $$ = create_expr($2, $1, $3); }
					| term { $$ = $1; }

addop : T_PLUS { $$ = EXPR_ADD; }
	  | T_MINUS { $$ = EXPR_SUB; }

term : term mulop factor { $$ = create_expr($2, $1, $3); }
	 | factor { $$ = $1; }

mulop : T_MUL { $$ = EXPR_MUL; }
	  | T_DIV { $$ = EXPR_DIV; }

factor : T_LPAREN expression T_RPAREN { $$ = $2; }
	   | var { $$ = $1; }
	   | call { $$ = $1; } 
	   | T_NUM { $$ = expr_create_integer_literal(atoi(yytext)); }

call : T_ID T_LPAREN args T_RPAREN { 
	struct expr *n = expr_create_name($1);
	$$ = create_expr(EXPR_CALL, n, $3);
}

args : arg_list { $$ = $1; }
	 | %empty { $$ = NULL; }

arg_list : expression T_COMMA arg_list { $$ = create_expr(EXPR_ARG, $1, $3); }
		 | expression { $$ = create_expr(EXPR_ARG, $1, NULL); }

%%

int main(int argc, char* argv[]) {
	if (argc != 3) {
		printf("Must provide 2 arguments\n");
		return 1;
	}
	freopen (argv[2],"w",stdout);
	yyin = fopen(argv[1],"r"); 

	do {
		yyparse();
	} while(!feof(yyin));

	fclose(stdout);
	return 0;
}

void yyerror(const char* s) {
	printf("ERROR! %s\n", s);
	exit(1);
}